import subprocess
import pygraphviz
from Gen_graph import *
from Graph_simplify_2 import *
from Graph_assemble_2 import *


# 2015.12.08
# Use MultiDiGraph to add the paired-end information
# Use the new collapse method: collapse if two reads belong to the same genome
# 2015.12.07
# Use the mapped results of each read
# Calculate the node coverage and pair-end information
# the function for plotting the reads overlap generated by readjoiner
# 1. prefilter -des to produce the reads mapping between original IDs and new IDs
# 2. spmtest to extract the overlap smp file
# Collapsing nodes to outstand bifurcations in the graph

# 2016.02.25
# depth first search for assembly

# 2016.10.31
# generalize the program to analyze other datasets


###########################################################################
des_file=sys.argv[1]
edge_file=sys.argv[2]
fa_file=sys.argv[3]
pair_file=sys.argv[4]

# read_map: map read_name to read_index
# read_node_map: map read_index to node
#read_map_single, read_map_pair, read_single, read_pair, des_list, read_db = get_seq_from_fa_mix(fa_file, des_file) # read dictionary
#G, read_node_map = create_graph_mix(des_list, edge_file, len(read_map_single))
des_list, read_map, read_db = get_seq_from_fa(fa_file, des_file)
pair_dict = read_pair_file(pair_file, read_map)
G, read_node_map = create_graph(des_list, edge_file)
subgraphs=nx.weakly_connected_components(G)
print "Graph construction finished!"
print "Original whole graph, nodes number %d, edges number %d."%(len(G),len(G.edges()))

# parameters
read_len = 230
Fragment_len = 450
#read_len = 200
#Fragment_len = 350
overlap_cutoff = 180
binning_overlap_cutoff = 190
tip_len_cutoff = 500

# saved files
f_out=open('HIV_paths.txt','w')
f_out_un=open('HIV_paths_unassembled.txt','w')
f_out2=open('HIV_contigs.fa','w')
f_out2_un=open('HIV_contigs_unassembled.fa','w')

for gg in subgraphs:
    subgraph_simple = G.subgraph(gg)
    print "Original graph, nodes number %d, edges number %d."%(len(subgraph_simple), len(subgraph_simple.edges()))
    subgraph_simple=collapse_graph_2(G.subgraph(gg),read_db,read_node_map)
    print "Collapsed graph, nodes number %d, edges number %d."%(len(subgraph_simple), len(subgraph_simple.edges()))
    
    ## delete low overlap edges
    for this_edge in subgraph_simple.edges():
        if int(subgraph_simple.edge[this_edge[0]][this_edge[1]][0]['label'])<overlap_cutoff:
            subgraph_simple.remove_edge(this_edge[0],this_edge[1])
    subgraph_simple = collapse_graph_2(subgraph_simple, read_db, read_node_map)
    print "Collapsed graph after deleting low overlap edges, nodes number: %d, edges number: %d."%(len(subgraph_simple),len(subgraph_simple.edges()))


    ## binning the graph to remove random overlap edges
    old_edge_num=len(subgraph_simple.edges())
    new_edge_num=0
    old_node_num=len(subgraph_simple.nodes())
    new_node_num=0
    loop=0
    while old_edge_num!=new_edge_num or old_node_num!=new_node_num:
        loop+=1
        old_edge_num=len(subgraph_simple.edges())
        old_node_num=len(subgraph_simple.nodes())

        paired_end_edges, PE_G = create_paired_end_graph_with_pairs(read_node_map, pair_dict)
        for N in subgraph_simple.nodes():
            if not N in PE_G:
                PE_G.add_node(N)

        pair_end_binning(subgraph_simple, PE_G, binning_overlap_cutoff)  # delete edges with no pair-end supporting
        subgraph_simple=collapse_graph_2(subgraph_simple, read_db, read_node_map)
        new_edge_num=len(subgraph_simple.edges())
        new_node_num=len(subgraph_simple.nodes())
    print 'Loop:',loop
    print "After binning, the number of nodes: %d, number of edges: %d."%(new_node_num, new_edge_num)
    #plot_graph(subgraph_simple,'HIV_5_strains_part_graph.png')
    #pdb.set_trace()

    # remove tips and bubbles
    old_edge_num=len(subgraph_simple.edges())
    new_edge_num=0
    old_node_num=len(subgraph_simple.nodes())
    new_node_num=0
    loop=0
    while (old_edge_num!=new_edge_num) or (old_node_num!=new_node_num):
        old_edge_num=len(subgraph_simple.edges())
        old_node_num=len(subgraph_simple.nodes())
        remove_tips(subgraph_simple, read_db, tip_len_cutoff)
        remove_super_tips(subgraph_simple, read_db)
        collapse_graph_2(subgraph_simple,read_db,read_node_map)
        new_edge_num=len(subgraph_simple.edges())
        new_node_num=len(subgraph_simple.nodes())
        loop+=1

    paired_end_edges,PE_G = create_paired_end_graph_with_pairs(read_node_map, pair_dict)
    for N in subgraph_simple.nodes():
        if not N in PE_G:
            PE_G.add_node(N)
    pdb.set_trace()
    plot_graph(PE_G, 'Pair_end_graph.png')
    print "After removing tips and bubbles, nodes number: %d, number of edges: %d"%(len(subgraph_simple), len(subgraph_simple.edges()))
    #plot_graph(subgraph_simple,'HIV_5_strains_part_graph.png')
    
    
    pdb.set_trace()
    ## Find the paths from the graph
    all_paths=[]
    assembled_nodes=set([])
    starting_nodes=[n for n in subgraph_simple.nodes() if subgraph_simple.in_degree(n)==0]
    for start_node in starting_nodes:
        print "Begin a new start node:",start_node
        #paths=list(DFS_paths_paired_end_4(subgraph_simple, start_node, PE_G, read_db, Fragment_len))
        paths=list(DFS_paths_single_pair_end(subgraph_simple, start_node, PE_G, read_db, Fragment_len))
        all_paths.extend(paths)
        print len(all_paths)
    
    for path in all_paths:
        out_path="--".join(path)
        f_out.write(out_path+'\n')
        f_out.flush()
        assembled_nodes=assembled_nodes.union(set(path))

    contig_index=0
    contigs=get_assemblie3(subgraph_simple, all_paths, read_db)  # a dictionary, key: path information, value: assembled sequence
    for contig_key in contigs:
        #title='>'+contig_key+'_'+str(len(contigs[contig_key]))+'_'+str(contig_index)
        if len(contigs[contig_key])>=Fragment_len:
            title='>contig'+'_'+str(len(contigs[contig_key]))+'_'+str(contig_index)
            f_out2.write(title+'\n'+contigs[contig_key]+'\n')
            contig_index+=1
            f_out2.flush()
   
    pdb.set_trace()
    paths_unassembled=[]
    ## Handle the unassembled nodes
    unassembled_nodes=set(subgraph_simple.nodes())-assembled_nodes
    print "Unassembled nodes!", len(unassembled_nodes)
    old_un_num = len(unassembled_nodes)
    new_un_num = 0
    loop = 0
    while (len(unassembled_nodes)>0 and old_un_num!=new_un_num):
        old_un_num = len(unassembled_nodes)
        sub_sub_graph=subgraph_simple.subgraph(list(unassembled_nodes))
        #plot_graph(sub_sub_graph,'HIV_sub_sub_graph.png')

        new_starting_nodes=[n for n in sub_sub_graph.nodes() if sub_sub_graph.in_degree(n)==0]
        for start_node in new_starting_nodes:
            print start_node
            #paths=list(DFS_paths_single_pair_end_unassembled(subgraph_simple, start_node, PE_G, read_db, Fragment_len))
            paths=list(DFS_paths_single_pair_end_unassembled(subgraph_simple, start_node, PE_G, read_db, Fragment_len))
            paths_unassembled.extend(paths)
            for path in paths:
                out_path="--".join(path)
                f_out_un.write(out_path+'\n')
                f_out_un.flush()
                assembled_nodes=assembled_nodes.union(set(path))
        unassembled_nodes=set(subgraph_simple.nodes())-assembled_nodes
        new_un_num = len(unassembled_nodes)
        loop+=1
        
        ''' 
        start_idx = 0
        while len(unassembled_nodes)>0 and len(new_starting_nodes)>0:
            start_node=new_starting_nodes[start_idx%len(new_starting_nodes)]
            print start_node
            paths=list(DFS_paths_single_pair_end_unassembled(subgraph_simple, start_node, PE_G, read_db, Fragment_len))
            paths_unassembled.extend(paths)
            for path in paths:
                out_path="--".join(path)
                f_out_un.write(out_path+'\n')
                f_out_un.flush()
                assembled_nodes=assembled_nodes.union(set(path))
            unassembled_nodes=set(subgraph_simple.nodes())-assembled_nodes
            sub_sub_graph=subgraph_simple.subgraph(list(unassembled_nodes))
            new_starting_nodes=[n for n in sub_sub_graph.nodes() if sub_sub_graph.in_degree(n)==0]
            print "Unassembled nodes:",len(set(subgraph_simple.nodes())-assembled_nodes)
            if len(set(subgraph_simple.nodes())-assembled_nodes)==1:
                pdb.set_trace()
            start_idx+=1
        '''
        
        #pdb.set_trace()
        print "Loop: %d." % loop
        print "Unassembled nodes!",len(set(subgraph_simple.nodes())-assembled_nodes)

    ## assemble contigs from the subgraph
    contigs=get_assemblie3(subgraph_simple, paths_unassembled, read_db)  # a dictionary, key: path information, value: assembled sequence
    for contig_key in contigs:
        #title='>'+contig_key+'_'+str(len(contigs[contig_key]))+'_'+str(contig_index)
        if len(contigs[contig_key])>Fragment_len:
            title='>contig'+'_'+str(len(contigs[contig_key]))+'_'+str(contig_index)
            f_out2_un.write(title+'\n'+contigs[contig_key]+'\n')
            contig_index+=1

f_out.close()
f_out_un.close()
f_out2.close()
f_out2_un.close()


